// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by "ffi-gen".

library api;

import "dart:async";
import "dart:convert";
import "dart:ffi" as ffi;
import "dart:io" show Platform;
import "dart:isolate";
import "dart:typed_data";

class _DartApiEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> name;
  external ffi.Pointer<ffi.Void> ptr;
}

class _DartApi extends ffi.Struct {
  @ffi.Int32()
  external int major;

  @ffi.Int32()
  external int minor;

  external ffi.Pointer<_DartApiEntry> functions;
}

ffi.Pointer<T> _lookupDartSymbol<T extends ffi.NativeType>(String symbol) {
  final ffi.Pointer<_DartApi> api = ffi.NativeApi.initializeApiDLData.cast();
  final ffi.Pointer<_DartApiEntry> functions = api.ref.functions;
  for (var i = 0; i < 100; i++) {
    final func = functions.elementAt(i).ref;
    var symbol2 = "";
    var j = 0;
    while (func.name.elementAt(j).value != 0) {
      symbol2 += String.fromCharCode(func.name.elementAt(j).value);
      j += 1;
    }
    if (symbol == symbol2) {
      return func.ptr.cast();
    }
  }
  throw "symbol not found";
}

class _Box {
  final Api _api;
  final ffi.Pointer<ffi.Void> _ptr;
  final String _dropSymbol;
  bool _dropped;
  bool _moved;
  ffi.Pointer<ffi.Void> _finalizer = ffi.Pointer.fromAddress(0);

  _Box(this._api, this._ptr, this._dropSymbol)
      : _dropped = false,
        _moved = false;

  late final _dropPtr = _api._lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(_dropSymbol);

  late final _drop = _dropPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  int borrow() {
    if (_dropped) {
      throw StateError("use after free");
    }
    if (_moved) {
      throw StateError("use after move");
    }
    return _ptr.address;
  }

  int move() {
    if (_dropped) {
      throw StateError("use after free");
    }
    if (_moved) {
      throw StateError("can't move value twice");
    }
    _moved = true;
    _api._unregisterFinalizer(this);
    return _ptr.address;
  }

  void drop() {
    if (_dropped) {
      throw StateError("double free");
    }
    if (_moved) {
      throw StateError("can't drop moved value");
    }
    _dropped = true;
    _api._unregisterFinalizer(this);
    _drop(ffi.Pointer.fromAddress(0), _ptr);
  }
}

/// Implements Iterable and Iterator for a rust iterator.
class Iter<T> extends Iterable<T> implements Iterator<T> {
  final _Box _box;
  final T? Function(int) _next;

  Iter._(this._box, this._next);

  @override
  Iterator<T> get iterator => this;

  T? _current;

  @override
  T get current => _current!;

  @override
  bool moveNext() {
    final next = _next(_box.borrow());
    if (next == null) {
      return false;
    } else {
      _current = next;
      return true;
    }
  }

  void drop() {
    _box.drop();
  }
}

Future<T> _nativeFuture<T>(_Box box, T? Function(int, int, int) nativePoll) {
  final completer = Completer<T>();
  final rx = ReceivePort();
  void poll() {
    try {
      final ret = nativePoll(box.borrow(), ffi.NativeApi.postCObject.address,
          rx.sendPort.nativePort);
      if (ret == null) {
        return;
      }
      completer.complete(ret);
    } catch (err) {
      completer.completeError(err);
    }
    rx.close();
    box.drop();
  }

  rx.listen((dynamic _message) => poll());
  poll();
  return completer.future;
}

Stream<T> _nativeStream<T>(
    _Box box, T? Function(int, int, int, int) nativePoll) {
  final controller = StreamController<T>();
  final rx = ReceivePort();
  final done = ReceivePort();
  void poll() {
    try {
      final ret = nativePoll(
        box.borrow(),
        ffi.NativeApi.postCObject.address,
        rx.sendPort.nativePort,
        done.sendPort.nativePort,
      );
      if (ret != null) {
        controller.add(ret);
      }
    } catch (err) {
      controller.addError(err);
    }
  }

  void close() {
    rx.close();
    done.close();
    box.drop();
  }

  controller.onCancel = close;
  rx.listen((dynamic _message) => poll());
  done.listen((dynamic _message) => controller.close());
  poll();
  return controller.stream;
}

/// Main entry point to library.
class Api {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Api(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Api.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// The library is loaded from the executable.
  factory Api.loadStatic() {
    return Api(ffi.DynamicLibrary.executable());
  }

  /// The library is dynamically loaded.
  factory Api.loadDynamic(String name) {
    return Api(ffi.DynamicLibrary.open(name));
  }

  /// The library is loaded based on platform conventions.
  factory Api.load() {
    String? name;
    if (Platform.isLinux) name = "libapi.so";
    if (Platform.isAndroid) name = "libapi.so";
    if (Platform.isMacOS) name = "libapi.dylib";
    if (Platform.isIOS) name = "";
    if (Platform.isWindows) name = "api.dll";
    if (name == null) {
      throw UnsupportedError("\"This platform is not supported.\"");
    }
    if (name == "") {
      return Api.loadStatic();
    } else {
      return Api.loadDynamic(name);
    }
  }

  late final _registerPtr = _lookupDartSymbol<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, ffi.Pointer<ffi.Void>)>>("Dart_NewFinalizableHandle");

  late final _register = _registerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          Object, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> _registerFinalizer(_Box boxed) {
    return _register(boxed, boxed._ptr, 42, boxed._dropPtr.cast());
  }

  late final _unregisterPtr = _lookupDartSymbol<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Handle)>>("Dart_DeleteFinalizableHandle");

  late final _unregister =
      _unregisterPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, _Box)>();

  void _unregisterFinalizer(_Box boxed) {
    _unregister(boxed._finalizer, boxed);
  }

  ffi.Pointer<T> __allocate<T extends ffi.NativeType>(
      int byteCount, int alignment) {
    return _allocate(byteCount, alignment).cast();
  }

  void __deallocate<T extends ffi.NativeType>(
      ffi.Pointer pointer, int byteCount, int alignment) {
    _deallocate(pointer.cast(), byteCount, alignment);
  }

  OurStruct createS(
    int x,
    int y,
  ) {
    final tmp0 = x;
    final tmp2 = y;
    var tmp1 = 0;
    var tmp3 = 0;
    tmp1 = tmp0;
    tmp3 = tmp2;
    final tmp4 = _createS(
      tmp1,
      tmp3,
    );
    final tmp6 = tmp4;
    final ffi.Pointer<ffi.Void> tmp6_0 = ffi.Pointer.fromAddress(tmp6);
    final tmp6_1 = _Box(this, tmp6_0, "drop_box_OurStruct");
    tmp6_1._finalizer = this._registerFinalizer(tmp6_1);
    final tmp5 = OurStruct._(this, tmp6_1);
    return tmp5;
  }

  OurStructList newStructList() {
    final tmp0 = _newStructList();
    final tmp2 = tmp0;
    final ffi.Pointer<ffi.Void> tmp2_0 = ffi.Pointer.fromAddress(tmp2);
    final tmp2_1 = _Box(this, tmp2_0, "drop_box_OurStructList");
    tmp2_1._finalizer = this._registerFinalizer(tmp2_1);
    final tmp1 = OurStructList._(this, tmp2_1);
    return tmp1;
  }

  OurStructList createSs() {
    final tmp0 = _createSs();
    final tmp2 = tmp0;
    final ffi.Pointer<ffi.Void> tmp2_0 = ffi.Pointer.fromAddress(tmp2);
    final tmp2_1 = _Box(this, tmp2_0, "drop_box_OurStructList");
    tmp2_1._finalizer = this._registerFinalizer(tmp2_1);
    final tmp1 = OurStructList._(this, tmp2_1);
    return tmp1;
  }

  void printSs(
    OurStructList ss,
  ) {
    final tmp0 = ss;
    var tmp1 = 0;
    tmp1 = tmp0._box.move();
    _printSs(
      tmp1,
    );
    return;
  }

  late final _allocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr, ffi.IntPtr)>>("allocate");

  late final _allocate =
      _allocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int, int)>();

  late final _deallocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr, ffi.IntPtr)>>("deallocate");

  late final _deallocate = _deallocatePtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint8>, int, int)>();

  late final _createSPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
    ffi.Uint32,
    ffi.Uint32,
  )>>("__create_s");

  late final _createS = _createSPtr.asFunction<
      int Function(
    int,
    int,
  )>();
  late final _newStructListPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function()>>("__new_struct_list");

  late final _newStructList = _newStructListPtr.asFunction<int Function()>();
  late final _createSsPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function()>>("__create_ss");

  late final _createSs = _createSsPtr.asFunction<int Function()>();
  late final _printSsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
    ffi.Int64,
  )>>("__print_ss");

  late final _printSs = _printSsPtr.asFunction<
      void Function(
    int,
  )>();
  late final _ourStructPrintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
    ffi.Int64,
  )>>("__OurStruct_print");

  late final _ourStructPrint = _ourStructPrintPtr.asFunction<
      void Function(
    int,
  )>();
  late final _ourStructListAddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
    ffi.Int64,
    ffi.Int64,
  )>>("__OurStructList_add");

  late final _ourStructListAdd = _ourStructListAddPtr.asFunction<
      void Function(
    int,
    int,
  )>();
  late final _ourStructListPrintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
    ffi.Int64,
  )>>("__OurStructList_print");

  late final _ourStructListPrint = _ourStructListPrintPtr.asFunction<
      void Function(
    int,
  )>();
  late final _ourStructListGetPtr = _lookup<
      ffi.NativeFunction<
          _OurStructListGetReturn Function(
    ffi.Int64,
    ffi.Uint64,
  )>>("__OurStructList_get");

  late final _ourStructListGet = _ourStructListGetPtr.asFunction<
      _OurStructListGetReturn Function(
    int,
    int,
  )>();
}

class OurStruct {
  final Api _api;
  final _Box _box;

  OurStruct._(this._api, this._box);

  void print() {
    var tmp0 = 0;
    tmp0 = _box.borrow();
    _api._ourStructPrint(
      tmp0,
    );
    return;
  }

  /// Manually drops the object and unregisters the FinalizableHandle.
  void drop() {
    _box.drop();
  }
}

class OurStructList {
  final Api _api;
  final _Box _box;

  OurStructList._(this._api, this._box);

  void add(
    OurStruct s,
  ) {
    final tmp1 = s;
    var tmp0 = 0;
    var tmp2 = 0;
    tmp0 = _box.borrow();
    tmp2 = tmp1._box.move();
    _api._ourStructListAdd(
      tmp0,
      tmp2,
    );
    return;
  }

  void print() {
    var tmp0 = 0;
    tmp0 = _box.borrow();
    _api._ourStructListPrint(
      tmp0,
    );
    return;
  }

  OurStruct? get_(
    int index,
  ) {
    final tmp1 = index;
    var tmp0 = 0;
    var tmp2 = 0;
    tmp0 = _box.borrow();
    tmp2 = tmp1;
    final tmp3 = _api._ourStructListGet(
      tmp0,
      tmp2,
    );
    final tmp5 = tmp3.arg0;
    final tmp6 = tmp3.arg1;
    if (tmp5 == 0) {
      return null;
    }
    final ffi.Pointer<ffi.Void> tmp6_0 = ffi.Pointer.fromAddress(tmp6);
    final tmp6_1 = _Box(_api, tmp6_0, "drop_box_OurStruct");
    tmp6_1._finalizer = _api._registerFinalizer(tmp6_1);
    final tmp4 = OurStruct._(_api, tmp6_1);
    return tmp4;
  }

  /// Manually drops the object and unregisters the FinalizableHandle.
  void drop() {
    _box.drop();
  }
}

class _OurStructListGetReturn extends ffi.Struct {
  @ffi.Uint8()
  external int arg0;
  @ffi.Int64()
  external int arg1;
}
