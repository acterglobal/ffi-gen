// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by "ffi-gen".
/* tslint:disable */
/* eslint:disable */

let fs;
const fetch_polyfill = async (file) => {
  const readFile = await eval("mport('fs')".replace(/^/, "i")).then(
    ({ readFile }) => readFile
  );
  return new Promise((resolve, reject) => {
    readFile(file, function (err, data) {
      return err
        ? reject(err)
        : resolve({
            arrayBuffer: () => Promise.resolve(data),
            ok: true,
          });
    });
  });
};

let ReadableStream;
if (typeof window == "object") {
  ReadableStream = window.ReadableStream;
  // Workaround for combined use with `wasm-bindgen`, so we don't have to
  // patch the `importObject` while loading the WASM module.
  window.__notifier_callback = (idx) => notifierRegistry.callbacks[idx]();
} else {
  eval("mport('node:stream/web')".replace(/^/, "i")).then((pkg) => {
    ReadableStream = pkg.ReadableStream;
  });
  // Workaround for combined use with `wasm-bindgen`, so we don't have to
  // patch the `importObject` while loading the WASM module.
  global.__notifier_callback = (idx) => notifierRegistry.callbacks[idx]();
}

const fetchFn = (typeof fetch === "function" && fetch) || fetch_polyfill;

function fetchAndInstantiate(url, imports) {
  const env = imports.env || {};
  env.__notifier_callback = (idx) => notifierRegistry.callbacks[idx]();
  imports.env = env;
  return fetchFn(url)
    .then((resp) => {
      if (!resp.ok) {
        throw new Error("Got a ${resp.status} fetching wasm @ ${url}");
      }

      const wasm = "application/wasm";
      const type = resp.headers && resp.headers.get("content-type");

      return WebAssembly.instantiateStreaming && type === wasm
        ? WebAssembly.instantiateStreaming(resp, imports)
        : resp
            .arrayBuffer()
            .then((buf) => WebAssembly.instantiate(buf, imports));
    })
    .then((result) => result.instance);
}

const dropRegistry = new FinalizationRegistry((drop) => drop());

class Box {
  constructor(ptr, destructor) {
    this.ptr = ptr;
    this.dropped = false;
    this.moved = false;
    dropRegistry.register(this, destructor, this);
    this.destructor = destructor;
  }

  borrow() {
    if (this.dropped) {
      throw new Error("use after free");
    }
    if (this.moved) {
      throw new Error("use after move");
    }
    return this.ptr;
  }

  move() {
    if (this.dropped) {
      throw new Error("use after free");
    }
    if (this.moved) {
      throw new Error("can't move value twice");
    }
    this.moved = true;
    dropRegistry.unregister(this);
    return this.ptr;
  }

  drop() {
    if (this.dropped) {
      throw new Error("double free");
    }
    if (this.moved) {
      throw new Error("can't drop moved value");
    }
    this.dropped = true;
    dropRegistry.unregister(this);
    this.destructor();
  }
}

class NotifierRegistry {
  constructor() {
    this.counter = 0;
    this.callbacks = {};
  }

  reserveSlot() {
    const idx = this.counter;
    this.counter += 1;
    return idx;
  }

  registerNotifier(idx, notifier) {
    this.callbacks[idx] = notifier;
  }

  unregisterNotifier(idx) {
    delete this.callbacks[idx];
  }
}

const notifierRegistry = new NotifierRegistry();

const nativeFuture = (box, nativePoll) => {
  const poll = (resolve, reject, idx) => {
    try {
      const ret = nativePoll(box.borrow(), 0, BigInt(idx));
      if (ret == null) {
        return;
      }
      resolve(ret);
    } catch (err) {
      reject(err);
    }
    notifierRegistry.unregisterNotifier(idx);
    box.drop();
  };
  return new Promise((resolve, reject) => {
    const idx = notifierRegistry.reserveSlot();
    const notifier = () => poll(resolve, reject, idx);
    notifierRegistry.registerNotifier(idx, notifier);
    poll(resolve, reject, idx);
  });
};

function* nativeIter(box, nxt) {
  let el;
  while (true) {
    el = nxt(box.borrow());
    if (el === null) {
      break;
    }
    yield el;
  }
  box.drop();
}

const nativeStream = (box, nativePoll) => {
  const poll = (next, nextIdx, doneIdx) => {
    const ret = nativePoll(box.borrow(), 0, BigInt(nextIdx), BigInt(doneIdx));
    if (ret != null) {
      next(ret);
    }
  };
  return new ReadableStream({
    start(controller) {
      const nextIdx = notifierRegistry.reserveSlot();
      const doneIdx = notifierRegistry.reserveSlot();
      const nextNotifier = () =>
        setTimeout(
          () => poll((x) => controller.enqueue(x), nextIdx, doneIdx),
          0
        );
      const doneNotifier = () => {
        notifierRegistry.unregisterNotifier(nextIdx);
        notifierRegistry.unregisterNotifier(doneIdx);
        controller.close();
        box.drop();
      };
      notifierRegistry.registerNotifier(nextIdx, nextNotifier);
      notifierRegistry.registerNotifier(doneIdx, doneNotifier);
      nextNotifier();
    },
  });
};

export class Api {
  async fetch(url, imports) {
    this.instance = await fetchAndInstantiate(url, imports);
  }

  initWithInstance(instance) {
    this.instance = instance;
  }

  allocate(size, align) {
    return this.instance.exports.allocate(size, align);
  }

  deallocate(ptr, size, align) {
    this.instance.exports.deallocate(ptr, size, align);
  }

  drop(symbol, ptr) {
    this.instance.exports[symbol](0, ptr);
  }

  createS(x, y) {
    const tmp0 = x;
    const tmp2 = y;
    let tmp1 = 0;
    let tmp3 = 0;
    tmp1 = tmp0;
    tmp3 = tmp2;
    const tmp4 = this.instance.exports.__create_s(tmp1, tmp3);
    const tmp6 = tmp4;
    const tmp6_0 = () => {
      this.drop("drop_box_OurStruct", tmp6);
    };
    const tmp6_1 = new Box(tmp6, tmp6_0);
    const tmp5 = new OurStruct(this, tmp6_1);
    return tmp5;
  }
  newStructList() {
    const tmp0 = this.instance.exports.__new_struct_list();
    const tmp2 = tmp0;
    const tmp2_0 = () => {
      this.drop("drop_box_OurStructList", tmp2);
    };
    const tmp2_1 = new Box(tmp2, tmp2_0);
    const tmp1 = new OurStructList(this, tmp2_1);
    return tmp1;
  }
  createSs() {
    const tmp0 = this.instance.exports.__create_ss();
    const tmp2 = tmp0;
    const tmp2_0 = () => {
      this.drop("drop_box_OurStructList", tmp2);
    };
    const tmp2_1 = new Box(tmp2, tmp2_0);
    const tmp1 = new OurStructList(this, tmp2_1);
    return tmp1;
  }
  printSs(ss) {
    const tmp0 = ss;
    let tmp1 = 0;
    tmp1 = tmp0.box.move();
    this.instance.exports.__print_ss(tmp1);
    return;
  }
}

export class OurStruct {
  constructor(api, box) {
    this.api = api;
    this.box = box;
  }

  print() {
    let tmp0 = 0;
    tmp0 = this.box.borrow();
    this.api.instance.exports.__OurStruct_print(tmp0);
    return;
  }

  drop() {
    this.box.drop();
  }
}
export class OurStructList {
  constructor(api, box) {
    this.api = api;
    this.box = box;
  }

  add(s) {
    const tmp1 = s;
    let tmp0 = 0;
    let tmp2 = 0;
    tmp0 = this.box.borrow();
    tmp2 = tmp1.box.move();
    this.api.instance.exports.__OurStructList_add(tmp0, tmp2);
    return;
  }
  print() {
    let tmp0 = 0;
    tmp0 = this.box.borrow();
    this.api.instance.exports.__OurStructList_print(tmp0);
    return;
  }
  get(index) {
    const tmp1 = index;
    let tmp0 = 0;
    let tmp2 = 0;
    tmp0 = this.box.borrow();
    tmp2 = tmp1;
    const tmp3 = this.api.instance.exports.__OurStructList_get(tmp0, tmp2);
    const tmp5 = tmp3[0];
    const tmp6 = tmp3[1];
    if (tmp5 === 0) {
      return null;
    }
    const tmp6_0 = () => {
      this.api.drop("drop_box_OurStruct", tmp6);
    };
    const tmp6_1 = new Box(tmp6, tmp6_0);
    const tmp4 = new OurStruct(this.api, tmp6_1);
    return tmp4;
  }

  drop() {
    this.box.drop();
  }
}

export default Api;
